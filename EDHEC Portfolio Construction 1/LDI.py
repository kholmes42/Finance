# -*- coding: utf-8 -*-
"""
Created on Fri Feb 24 14:20:57 2023
Week 4 Intro LDI
@author: kholm
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt




def discount_factor(t,r):
    """
    compute PV of discount bond with flat yield curve
    """
   
    discounts = pd.DataFrame([(r+1)**-i for i in t])
    discounts.index = t
    return discounts



def PV(lib,r):
    """
    compute PV of sequence of liabilities
    lib - indexed by time
    """
    dates = lib.index
    discounts = discount_factor(dates, r)
    return discounts.multiply(lib, axis='rows').sum()
    
    


def funding_ratio(assets,libs,r):
    """
    compute funding ratio
    """
   
    return PV(assets,r)/PV(libs,r)


def inst_to_ann(r):
    """
    convert short rate to ann rate
    """
    return np.exp(r) - 1



def ann_to_inst(r):
    """
    convert  ann rate to short rate
    """
    
    return np.log1p(r)



def CIR_model(r0,a=0.05,b=0.03,sigma=0.05,steps=12,periods=10,n=1):
    """
    Calculate Cox Ingersoll Ross rate 
    """
    
    rt = ann_to_inst(r0)
    s = np.random.normal(0,np.sqrt(1/steps),size=(steps*periods,n))
    
    
    rates = np.empty_like(s)
    rates[0] = rt
    
    for i in range(1,steps*periods):
        rt = rates[i-1]
        
        drt = a*(b-rt)/steps + sigma*np.sqrt(rt)*s[i]
        
        rates[i] = abs(rt + drt)
    
    
    
    def zero_price(row):
        
        h = np.sqrt(a**2 + 2*sigma**2)
        tau = (row.index - row.index.max())*-1/(steps)
   
        A = ((2*h*np.exp((a+h)*tau/2))/(2*h + (a+h)*(np.exp(tau*h)-1)))**(2*a*b/sigma**2)
        B = 2*(np.exp(tau*h)-1)/((2*h + (a+h)*(np.exp(tau*h)-1)))
        
        P = A*np.exp(-B*row)
     
        return P
    
    pr= pd.DataFrame(rates).apply(zero_price,axis=0)
    
    
    return pd.DataFrame(data=inst_to_ann(rates)),pr


def create_cpn_bond(maturity, principal=100, coupon_rate=0.03, coupons_per_year=12):
    """
    Returns the series of cash flows generated by a bond,
    indexed by the payment/coupon number
    """
    n_coupons = round(maturity*coupons_per_year)
    coupon_amt = principal*coupon_rate/coupons_per_year
 
    coupon_times = np.arange(1, n_coupons+1)
    cash_flows = pd.Series(data=coupon_amt, index=coupon_times)
    cash_flows.iloc[-1] += principal
    return cash_flows



def mac_duration(flows,disc_rate):
    """
    compute macaualay duration
    """
    disc_flows = discount_factor(flows.index,disc_rate)*pd.DataFrame(flows)
    
    wgt = disc_flows/disc_flows.sum()
    return np.average(flows.index,weights=wgt.iloc[:,0])


def match_durations(cf_t, cf_s, cf_l, discount_rate):
    """
    Returns the weight W in cf_s that, along with (1-W) in cf_l will have an effective
    duration that matches cf_t
    """
    d_t = mac_duration(cf_t, discount_rate)
    d_s = mac_duration(cf_s, discount_rate)
    d_l = mac_duration(cf_l, discount_rate)
    
    ws = (d_l - d_t)/(d_l - d_s)
    wl = 1 - ws
    return ws,wl

def bond_price(maturity, principal=100, coupon_rate=0.03, coupons_per_year=12, discount_rate=0.03):
    """
    Computes the price of a bond that pays regular coupons until maturity
    at which time the principal and the final coupon is returned
    This is not designed to be efficient, rather,
    it is to illustrate the underlying principle behind bond pricing!
    If discount_rate is a DataFrame, then this is assumed to be the rate on each coupon date
    and the bond value is computed over time.
    i.e. The index of the discount_rate DataFrame is assumed to be the coupon number
    """
    if isinstance(discount_rate, pd.DataFrame):
        pricing_dates = discount_rate.index
        prices = pd.DataFrame(index=pricing_dates, columns=discount_rate.columns)
        for t in pricing_dates:
            prices.loc[t] = bond_price(maturity-t/coupons_per_year, principal, coupon_rate, coupons_per_year,
                                      discount_rate.loc[t])
        return prices
    else: # base case ... single time period
        if maturity <= 0: return principal+principal*coupon_rate/coupons_per_year
        cash_flows = create_cpn_bond(maturity, principal, coupon_rate, coupons_per_year)
        return PV(cash_flows, discount_rate/coupons_per_year)


def bond_total_return(monthly_prices, principal, coupon_rate, coupons_per_year):
    """
    Computes the total return of a Bond based on monthly bond prices and coupon payments
    Assumes that dividends (coupons) are paid out at the end of the period (e.g. end of 3 months for quarterly div)
    and that dividends are reinvested in the bond
    """
    coupons = pd.DataFrame(data = 0, index=monthly_prices.index, columns=monthly_prices.columns)
    t_max = monthly_prices.index.max()
    pay_date = np.linspace(12/coupons_per_year, t_max, int(coupons_per_year*t_max/12), dtype=int)
    coupons.iloc[pay_date] = principal*coupon_rate/coupons_per_year
    total_returns = (monthly_prices + coupons)/monthly_prices.shift()-1
    return total_returns.dropna()

def ann_ret(data):
    return ((np.array(np.cumprod(1+(data)))[-1])**(12/len(data))-1)


def gbm(periods = 10,steps_per_period=12, n=1000,mu = 0.07,sigma=0.15):
    """
    Use simple GBM to generate price returns
    """
  
    r_drift = np.random.normal(1+mu/steps_per_period, sigma*np.sqrt(1/steps_per_period),size=(periods*steps_per_period,n))
    prices = 100*pd.DataFrame(( r_drift )).cumprod()
    
    return prices


r,pr = CIR_model(r0=0.03,a=0.05,b=0.03,n=500,sigma=0.05)
fig,ax = plt.subplots(1,2,figsize=(20,8))
r.plot(legend=False,ax=ax[0])
ax[0].set_xlim(0)
ax[0].set_title("CIR Short Rate Model")
ax[0].set_xlabel("T")
ax[0].set_ylabel("Rate")

pr.plot(legend=False,ax=ax[1])
ax[1].set_xlim(0)
ax[1].set_title("CIR Zero Price")
ax[1].set_xlabel("T")
ax[1].set_ylabel("Price")



#model A/L
liabilities = pr
assets = 0.75


#calc PV of liabilities
pvlib = liabilities.iloc[0,:]

#calc hedge ratio using ZC bond
hr = assets/pvlib

#evolution of hedging portfolio
zc_hedging_port = hr*pr 
cash_hedging_port = assets*(r/12+1).cumprod()


#funding ratio
fig,ax = plt.subplots(1,2,figsize=(20,8))
(np.round(zc_hedging_port/liabilities,2)).pct_change().plot(legend=False,ax=ax[0])
ax[0].set_xlim(0)
ax[0].set_title("Zero Coupon Bond Hedging Funding Ratio Returns")
ax[0].set_xlabel("T")
ax[0].set_ylabel("Return")

(np.round(cash_hedging_port/liabilities,2)).pct_change().plot(legend=False,ax=ax[1])
ax[1].set_xlim(0)
ax[1].set_title("Cash Hedging Funding Ratio Returns")
ax[1].set_xlabel("T")
ax[1].set_ylabel("Return")

plt.figure()
ending_fund_cash = cash_hedging_port.iloc[-1,:]/liabilities.iloc[-1,:]
ending_fund_zc = zc_hedging_port.iloc[-1,:]/liabilities.iloc[-1,:]
ending_fund_cash.hist(bins=30,label="Cash Hedging")
ending_fund_zc.hist(bins=30,label="ZC Hedging")
plt.ylim(0,100)
plt.title("Final Funding Ratio Distribution")
plt.xlabel("Funding Ratio")
plt.ylabel("Count")
plt.legend(["Cash Hedging","ZC Hedging"])


#Duration matching
disrate = 0.04
assets = 130000
lib1 = pd.Series(data=[100000,100000],index=[10,12]) #liability at time 10,12
md_lib = mac_duration(lib1, disrate)

bond1 = create_cpn_bond(10, principal=1000, coupon_rate=0.05, coupons_per_year=1)
bond2 = create_cpn_bond(20, principal=1000, coupon_rate=0.05, coupons_per_year=1)


w1,w2 = match_durations(lib1, bond1, bond2, disrate)

pshortbond = PV(bond1,disrate)[0]
plongbond = PV(bond2,disrate)[0]


p_flows = pd.concat([(assets*w1/pshortbond)*bond1 , (assets*w2/plongbond)*bond2])
md_p = mac_duration(p_flows,disrate)


cfr = funding_ratio(p_flows, lib1, disrate)


rts = np.linspace(0,0.1,20)

longonly = []
shortonly = []
durmatch = []

for r in rts:
    p_flows = pd.concat([(assets*w1/pshortbond)*bond1 , (assets*w2/plongbond)*bond2])
    
    durmatch.append(funding_ratio(p_flows, lib1, r)[0])

    shortonly.append(funding_ratio(assets/pshortbond*bond1, lib1, r)[0])

    longonly.append(funding_ratio(assets/plongbond*bond2, lib1, r)[0])
    

plt.figure()
sns.lineplot(x=rts,y=durmatch,label="Duration Matched")
sns.lineplot(x=rts,y=longonly,label="Long Bond Only")
sns.lineplot(x=rts,y=shortonly,label="Short Bond Only")
plt.xlim(0)
plt.ylabel("Funding Ratio")
plt.xlabel("Interest Rate")
plt.title("Change in Funding Ratio for Change in Rate")




#LDI II

rates,zeros = CIR_model(0.03,b=0.03,n=500)

bp = bond_price(10,100,0.05,12,rates)
btr= ann_ret(bond_total_return(bp,100,0.05,12))

price_10y = bond_price(10,100,0.05,12,rates)
price_30y = bond_price(30,100,0.05,12,rates)


ret10 = bond_total_return(price_10y, 100,0.05, 12)
ret30 = bond_total_return(price_30y, 100,0.05, 12)

rets_10_and_30 = 0.6*ret10 + 0.4*ret30

eqty_price = gbm(periods=10,n=500,mu=0.07,sigma=0.15)
reteqty = eqty_price.pct_change().dropna()


rets7030 = 0.7*reteqty + 0.3*rets_10_and_30




#HW4
b1 = bond_price(15,1000,0.05,2,0.05)
b2 = bond_price(5,1000,0.06,4,0.05)
b3 = bond_price(10,1000,0,1,0.05)

md1 = mac_duration(create_cpn_bond(15, 1000, coupon_rate=0.05, coupons_per_year=2),0.05/2)/2
md2 = mac_duration(create_cpn_bond(5, 1000, coupon_rate=0.06, coupons_per_year=4),0.05/4)/4
md3 = mac_duration(create_cpn_bond(10, 1000, coupon_rate=0, coupons_per_year=1),0.05)


libs = pd.Series(index=[3,5,10],data=[100000,200000,300000])
libdur = mac_duration(libs, 0.05)



def match_durations2(cf_t, cf_s, cf_l, discount_rate):
    """
    Returns the weight W in cf_s that, along with (1-W) in cf_l will have an effective
    duration that matches cf_t
    """
    d_t = mac_duration(cf_t, discount_rate)
    d_s = mac_duration(cf_s, discount_rate/4)/4
    d_l = mac_duration(cf_l, discount_rate)

    ws = (d_l - d_t)/(d_l - d_s)
    wl = 1 - ws
    return ws,wl

print(match_durations2(libs, create_cpn_bond(5, 1000, coupon_rate=0.06, coupons_per_year=4), create_cpn_bond(10, 1000, coupon_rate=0, coupons_per_year=1), 0.05))